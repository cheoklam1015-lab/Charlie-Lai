<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>貪食蛇遊戲</title>
  <style>
    body {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      background-color: #222;
      font-family: Arial, sans-serif;
      color: white;
    }
    canvas {
      border: 2px solid #444;
      background-color: black;
    }
    #score {
      margin-top: 10px;
      font-size: 24px;
    }
    #game-over {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: rgba(0, 0, 0, 0.8);
      padding: 20px;
      border-radius: 10px;
      text-align: center;
      display: none;
    }
    button {
      margin-top: 10px;
      padding: 10px 20px;
      font-size: 18px;
      background-color: #e74c3c;
      color: white;
      border: none;
      border-radius: 5px;
      cursor: pointer;
    }
    button:hover {
      background-color: #c0392b;
    }
  </style>
</head>
<body>
  <div id="score">分數: 0</div>
  <canvas id="game" width="400" height="400"></canvas>
  <div id="game-over">
    <h2>遊戲結束！</h2>
    <p id="final-score">分數: 0</p>
    <button id="restart-btn">重新開始</button>
  </div>

  <script>
    const canvas = document.getElementById('game');
    const ctx = canvas.getContext('2d');
    const scoreDisplay = document.getElementById('score');
    const gameOverScreen = document.getElementById('game-over');
    const finalScoreDisplay = document.getElementById('final-score');
    const restartBtn = document.getElementById('restart-btn');

    // 設定
    const gridSize = 20;
    const cellSize = canvas.width / gridSize; // 每格 20px（400/20）

    // 初始狀態
    let snake = [
      { x: 10, y: 10 }
    ];
    let direction = 'right'; // 'up', 'down', 'left', 'right'
    let nextDirection = direction;
    let apple = generateApple();
    let score = 0;
    let gameRunning = true;
    let gameSpeed = 120; // 毫秒/幀（可調整難度）

    // 生成蘋果（避免生成在蛇身上）
    function generateApple() {
      let newApple;
      do {
        newApple = {
          x: Math.floor(Math.random() * gridSize),
          y: Math.floor(Math.random() * gridSize)
        };
      } while (snake.some(segment => segment.x === newApple.x && segment.y === newApple.y));
      return newApple;
    }

    // 繪製蛇
    function drawSnake() {
      snake.forEach((segment, index) => {
        ctx.fillStyle = index === 0 ? '#3498db' : '#2ecc71'; // 頭部藍色，身體綠色
        ctx.fillRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
        // 加邊框
        ctx.strokeStyle = '#27ae60';
        ctx.strokeRect(segment.x * cellSize, segment.y * cellSize, cellSize, cellSize);
      });
    }

    // 繪製蘋果
    function drawApple() {
      ctx.fillStyle = 'red';
      ctx.beginPath();
      const centerX = apple.x * cellSize + cellSize / 2;
      const centerY = apple.y * cellSize + cellSize / 2;
      const radius = cellSize / 2 - 2;
      ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
      ctx.fill();

      // 蘋果梗
      ctx.fillStyle = '#795548';
      ctx.fillRect(centerX - 1, apple.y * cellSize + 2, 2, 4);
    }

    // 更新蛇的位置
    function moveSnake() {
      if (!gameRunning) return;

      direction = nextDirection;

      // 計算新頭部位置
      const head = { ...snake[0] };
      switch (direction) {
        case 'up': head.y--; break;
        case 'down': head.y++; break;
        case 'left': head.x--; break;
        case 'right': head.x++; break;
      }

      // 檢查撞牆
      if (head.x < 0 || head.x >= gridSize || head.y < 0 || head.y >= gridSize) {
        gameOver();
        return;
      }

      // 檢查撞自己
      if (snake.some(segment => segment.x === head.x && segment.y === head.y)) {
        gameOver();
        return;
      }

      // 插入新頭部
      snake.unshift(head);

      // 檢查是否吃到蘋果
      if (head.x === apple.x && head.y === apple.y) {
        // 吃到：不移除尾部，分數+1，生成新蘋果
        score++;
        scoreDisplay.textContent = `分數: ${score}`;
        apple = generateApple();
        // 隨分數提高速度（可選）
        if (score % 5 === 0 && gameSpeed > 60) {
          gameSpeed -= 5;
        }
      } else {
        // 沒吃到：移除尾部
        snake.pop();
      }
    }

    // 畫面更新
    function draw() {
      // 清空畫布
      ctx.fillStyle = 'black';
      ctx.fillRect(0, 0, canvas.width, canvas.height);

      // 繪製網格（可選，提升視覺效果）
      ctx.strokeStyle = '#111';
      for (let i = 0; i <= gridSize; i++) {
        ctx.beginPath();
        ctx.moveTo(i * cellSize, 0);
        ctx.lineTo(i * cellSize, canvas.height);
        ctx.stroke();

        ctx.beginPath();
        ctx.moveTo(0, i * cellSize);
        ctx.lineTo(canvas.width, i * cellSize);
        ctx.stroke();
      }

      drawApple();
      drawSnake();
    }

    // 遊戲主循環
    function gameLoop() {
      moveSnake();
      draw();
      if (gameRunning) {
        setTimeout(gameLoop, gameSpeed);
      }
    }

    // 遊戲結束
    function gameOver() {
      gameRunning = false;
      finalScoreDisplay.textContent = `分數: ${score}`;
      gameOverScreen.style.display = 'block';
    }

    // 重新開始
    function restart() {
      snake = [{ x: 10, y: 10 }];
      direction = 'right';
      nextDirection = direction;
      apple = generateApple();
      score = 0;
      gameSpeed = 120;
      scoreDisplay.textContent = `分數: ${score}`;
      gameOverScreen.style.display = 'none';
      gameRunning = true;
      gameLoop();
    }

    // 鍵盤控制
    document.addEventListener('keydown', (e) => {
      // 防止反向移動（不能直接掉頭）
      switch (e.key) {
        case 'ArrowUp':
          if (direction !== 'down') nextDirection = 'up';
          break;
        case 'ArrowDown':
          if (direction !== 'up') nextDirection = 'down';
          break;
        case 'ArrowLeft':
          if (direction !== 'right') nextDirection = 'left';
          break;
        case 'ArrowRight':
          if (direction !== 'left') nextDirection = 'right';
          break;
      }
    });

    // 重新開始按鈕
    restartBtn.addEventListener('click', restart);

    // 啟動遊戲
    draw(); // 先畫初始畫面
    gameLoop();
  </script>
</body>
</html>